/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
};
/*! @drupal/once - v1.0.1 - 2021-06-12 */
var once=function(){"use strict";var n=/[\11\12\14\15\40]+/,e="data-once",t=document;function r(n,t,r){return n[t+"Attribute"](e,r)}function o(e){if("string"!=typeof e)throw new TypeError("once ID must be a string");if(""===e||n.test(e))throw new RangeError("once ID must not be empty or contain spaces");return'[data-once~="'+e+'"]'}function u(n){if(!(n instanceof Element))throw new TypeError("The element must be an instance of Element");return!0}function i(n,e){void 0===e&&(e=t);var r=n;if(null===n)r=[];else{if(!n)throw new TypeError("Selector must not be empty");"string"!=typeof n||e!==t&&!u(e)?n instanceof Element&&(r=[n]):r=e.querySelectorAll(n)}return Array.prototype.slice.call(r)}function c(n,e,t){return e.filter((function(e){var r=u(e)&&e.matches(n);return r&&t&&t(e),r}))}function f(e,t){var o=t.add,u=t.remove,i=[];r(e,"has")&&r(e,"get").trim().split(n).forEach((function(n){i.indexOf(n)<0&&n!==u&&i.push(n)})),o&&i.push(o);var c=i.join(" ");r(e,""===c?"remove":"set",c)}function a(n,e,t){return c(":not("+o(n)+")",i(e,t),(function(e){return f(e,{add:n})}))}return a.remove=function(n,e,t){return c(o(n),i(e,t),(function(e){return f(e,{remove:n})}))},a.filter=function(n,e,t){return c(o(n),i(e,t))},a.find=function(n,e){return i(n?o(n):"[data-once]",e)},a}();

;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function () {
  var settingsElement = document.querySelector('head > script[type="application/json"][data-drupal-selector="drupal-settings-json"], body > script[type="application/json"][data-drupal-selector="drupal-settings-json"]');
  window.drupalSettings = {};

  if (settingsElement !== null) {
    window.drupalSettings = JSON.parse(settingsElement.textContent);
  }
})();;
window.drupalTranslations = {"strings":{"":{"Home":"Startseite","Status":"Status","List":"Liste","closed":"geschlossen","Cancel":"Abbrechen","Disabled":"Deaktiviert","Enabled":"Aktiviert","Edit":"Bearbeiten","Size":"Gr\u00f6\u00dfe","Link":"Link","Image":"Bild","Open":"Ge\u00f6ffnet","Add":"Hinzuf\u00fcgen","Filename":"Dateiname","Continue":"Weiter","N\/A":"n. v.","Close":"Schlie\u00dfen","Show":"Anzeigen","Select all rows in this table":"Alle Zeilen dieser Tabelle ausw\u00e4hlen","Deselect all rows in this table":"Alle Zeilen dieser Tabelle abw\u00e4hlen","Caption":"Beschriftung","Extend":"Erweitern","Changed":"Ge\u00e4ndert","Not published":"Nicht ver\u00f6ffentlicht","Loading...":"Wird geladen...","Please wait...":"Bitte warten...","Hide":"Ausblenden","Unlink":"Link entfernen","Not promoted":"nicht auf der Startseite","Error message":"Fehlermeldung","Warning message":"Warnmeldung","Edit Link":"Link bearbeiten","Remove group":"Gruppe entfernen","By @name on @date":"Von @name am @date","By @name":"Von @name","Not in menu":"Nicht im Men\u00fc","Alias: @alias":"Alias: @alias","No alias":"Kein Alias","@label":"@label","New revision":"Neue Revision","Drag to re-order":"Ziehen, um die Reihenfolge zu \u00e4ndern","Changes made in this table will not be saved until the form is submitted.":"\u00c4nderungen in dieser Tabelle werden nicht gespeichert, bis dieses Formular abgesendet wurde.","Show description":"Beschreibung anzeigen","This permission is inherited from the authenticated user role.":"Diese Berechtigung wird von der Rolle \u201aAuthentifizierte Benutzer\u2018 ererbt.","Requires a title":"Ben\u00f6tigt einen Titel","Not restricted":"Uneingeschr\u00e4nkt","(active tab)":"(aktiver Reiter)","Status message":"Statusmeldung","An AJAX HTTP error occurred.":"Ein AJAX-HTTP-Fehler ist aufgetreten.","HTTP Result Code: !status":"HTTP-R\u00fcckgabe-Code: !status","An AJAX HTTP request terminated abnormally.":"Eine AJAX-Anfrage ist abnormal beendet worden.","Debugging information follows.":"Im Folgenden finden Sie Debugging-Informationen.","Path: !uri":"Pfad: !uri","StatusText: !statusText":"Statustext: !statusText","ResponseText: !responseText":"Antworttext: !responseText","ReadyState: !readyState":"ReadyState: !readyState","Restricted to certain pages":"Auf bestimmte Seiten eingeschr\u00e4nkt","The block cannot be placed in this region.":"Der Block kann nicht in dieser Region abgelegt werden.","Don\u0027t display post information":"Beitragsinformationen nicht anzeigen","Collapse":"Zusammenklappen","The selected file %filename cannot be uploaded. Only files with the following extensions are allowed: %extensions.":"Die ausgew\u00e4hlte Datei %filename konnte nicht hochgeladen werden. Nur Dateien mit den folgenden Erweiterungen sind zul\u00e4ssig: %extensions.","Show row weights":"Zeilenreihenfolge anzeigen","Hide row weights":"Zeilenreihenfolge ausblenden","Apply (all displays)":"Anwenden (alle Anzeigen)","Apply (this display)":"Anwenden (diese Anzeige)","Revert to default":"Auf Standardwert zur\u00fccksetzen","Hide description":"Beschreibung ausblenden","Needs to be updated":"Aktualisierung erforderlich","Does not need to be updated":"Keine Aktualisierung erforderlich","Show all columns":"Alle Spalten zeigen","Show table cells that were hidden to make the table fit within a small screen.":"Zeige die Tabellenzellen, die ausgeblendet wurden, um die Tabelle auf kleinen Bildschirmen anzeigen zu k\u00f6nnen.","List additional actions":"Weitere Aktionen auflisten","Flag other translations as outdated":"Andere \u00dcbersetzungen als veraltet kennzeichnen","Do not flag other translations as outdated":"Andere \u00dcbersetzungen nicht als veraltet kennzeichnen","opened":"ge\u00f6ffnet","Horizontal orientation":"Horizontale Ausrichtung","Vertical orientation":"Vertikale Ausrichtung","Tray orientation changed to @orientation.":"Ausrichtung der aufklappbaren Einstellungsleiste in  @orientation ge\u00e4ndert.","You have unsaved changes.":"Es sind nicht gespeicherte \u00c4nderungen vorhanden.","Available buttons":"Verf\u00fcgbare Buttons","Active toolbar":"Aktive Werkzeugleiste","@action @title configuration options":"@action @title Konfigurationseinstellungen","Tabbing is no longer constrained by the Contextual module.":"Das Verwenden der Tabulatortaste wird nicht l\u00e4nger vom Contextual-Modul eingeschr\u00e4nkt.","Tabbing is constrained to a set of @contextualsCount and the edit mode toggle.":"Tabulatornavigation ist auf eine Gruppe von @contextualsCount und den Bearbeitungsmodusumschalter beschr\u00e4nkt.","Press the esc key to exit.":"Zum Beenden die Escape-Taste dr\u00fccken.","@count contextual link\u0003@count contextual links":"@count Kontextlink\u0003@count Kontextlinks","Based on the text editor configuration, these tags have automatically been added: \u003Cstrong\u003E@tag-list\u003C\/strong\u003E.":"Diese Tags wurden basierend auf der Konfiguration des Texteditors hinzugef\u00fcgt: \u003Cstrong\u003E@tag-list\u003C\/strong\u003E.","The toolbar cannot be set to a horizontal orientation when it is locked.":"Die Toolbar kann nicht horizontal angeordnet werden, wenn Sie gesperrt ist.","Enter caption here":"Beschriftung hinzuf\u00fcgen","Button divider":"Trennelement","Changing the text format to %text_format will permanently remove content that is not allowed in that text format.\u003Cbr\u003E\u003Cbr\u003ESave your changes before switching the text format to avoid losing data.":"Das \u00c4ndern des Textformats in %text_format entfernt dauerhaft Inhalt, der in diesem Textformat nicht erlaubt ist.\u003Cbr\u003E\u003Cbr\u003ESpeichern Sie Ihre \u00c4nderungen bevor Sie das Textformat umstellen, um Datenverlust zu vermeiden.","Change text format?":"Textformat \u00e4ndern?","Rich Text Editor, !label field":"Rich-Text-Editor, !label Feld","Leave preview?":"Vorschau verlassen?","Leave preview":"Vorschau verlassen","Leaving the preview will cause unsaved changes to be lost. Are you sure you want to leave the preview?":"Wenn Sie die Vorschau verlassen, gehen nicht gespeicherte \u00c4nderungen verloren. M\u00f6chten Sie die Vorschau wirklich verlassen?","CTRL+Left click will prevent this dialog from showing and proceed to the clicked link.":"Strg-Linkklick verhindert dass dieser Dialog angezeigt wird und geht auf den angeklickten Link.","Wrapping":"Umhebend","Tray \u0022@tray\u0022 @action.":"Aufklappbare Einstellungsleiste \u201e@tray\u201c @action.","Tray @action.":"Aufklappbare Einstellungsleiste @action.","Hide lower priority columns":"Niedrig priorisierte Spalten ausblenden","!modules modules are available in the modified list.":"!modules Module sind in der Modulfeldlsite verf\u00fcgbar.","The response failed verification so will not be processed.":"Die Verifizierung der Antwort ist fehlgeschlagen, deshalb wird die Verarbeitung nicht fortgef\u00fchrt.","The callback URL is not local and not trusted: !url":"Die Callback-URL ist nicht lokal und nicht vertrauensw\u00fcrdig: !url","CustomMessage: !customMessage":"Benutzerdefinierte Nachricht: !customMessage","Authored on @date":"Bearbeitet am @date","Divider":"Trennstrich","1 block is available in the modified list.\u0003@count blocks are available in the modified list.":"1 Block ist in der \u00fcberarbeiteten Liste verf\u00fcgbar.\u0003@count Bl\u00f6cke sind in der \u00fcberarbeiteten Liste verf\u00fcgbar.","Zero items selected":"Es wurde kein Eintrag ausgew\u00e4hlt","All @count items selected":"Alle @count Eintr\u00e4ge ausgew\u00e4hlt","Select all media":"Alle Medien ausw\u00e4hlen","Show media item weights":"Reihenfolge\/Gewichtung f\u00fcr Medieneintr\u00e4ge anzeigen","Hide media item weights":"Reihenfolge der Medieneintr\u00e4ge ausblenden","All available blocks are listed.":"Alle vorhandenen Bl\u00f6cke werden aufgelistet.","Block previews are visible. Block labels are hidden.":"Die Blockvorschau ist sichtbar. Blockbeschriftungen sind ausgeblendet.","Block previews are hidden. Block labels are visible.":"Die Blockvorschau ist ausgeblendet. Blockbeschriftungen sind sichtbar.","Button @name has been copied to the active toolbar.":"Der Button @name wurde in die aktive Symbolleiste kopiert.","Button @name has been removed from the active toolbar.":"Der Button @name wurde aus der aktiven Werkzeugleiste entfernt.","Button @name has been moved to the active toolbar.":"Der Button @name wurde in die aktive Werkzeugleiste verschoben.","@listType button @label":"@listType Button @label","Field Not Editable":"Feld nicht editierbar","CKEditor 5 is not compatible with IE11.":"CKEditor 5 ist nicht mit IE11 kompatibel.","Text editor toolbar settings are not available in Internet Explorer. They will be available in other \u003Ca href=\u0022@supported-browsers\u0022\u003Esupported browsers\u003C\/a\u003E.":"Die Einstellungen der Texteditor-Symbolleiste sind im Internet Explorer nicht verf\u00fcgbar. Sie werden in anderen \u003Ca href=\u0022@supported-browsers\u0022\u003Eunterst\u00fctzten Browsern\u003C\/a\u003E verf\u00fcgbar sein.","CKEditor 5 is not compatible with Internet Explorer. Text fields using CKEditor 5 will fall back to plain HTML editing without CKEditor for users of Internet Explorer.":"CKEditor 5 ist nicht mit dem Internet Explorer kompatibel. Textfelder, die CKEditor 5 verwenden, fallen f\u00fcr Benutzer des Internet Explorers auf einfache HTML-Bearbeitung ohne CKEditor zur\u00fcck.","A rich text editor is available for this field when used with \u003Ca href=\u0022@supported-browsers\u0022\u003Esupported browsers\u003C\/a\u003E other than Internet Explorer.":"Ein Rich-Text-Editor ist f\u00fcr dieses Feld verf\u00fcgbar, wenn es mit \u003Ca href=\u0022@supported-browsers\u0022\u003Eunterst\u00fctzten Browsern\u003C\/a\u003E au\u00dfer Internet Explorer verwendet wird.","Press the down arrow key to activate":"Dr\u00fccken Sie die Pfeiltaste nach unten, zur Aktivierung","Press the down arrow key to use this divider in the active button list":"Dr\u00fccken Sie die Pfeiltaste nach unten, um diese Unterteilung in der Liste der aktiven Buttons zu verwenden","Press the up arrow key to deactivate. Use the right and left arrow keys to move position":"Dr\u00fccken Sie zum Deaktivieren die Pfeiltaste nach oben. Verwenden Sie die rechte und linke Pfeiltaste zum Verschieben der Position","Restricted":"Eingeschr\u00e4nkt","Select files":"Dateien ausw\u00e4hlen","Edit @buttonLabel":"Bearbeiten von @buttonLabel","Embedded entity":"Eingebettete Entit\u00e4t","Embedded @buttonLabel":"@buttonLabel eingebettet","Automatic alias":"Automatisches Alias","Thumbnails":"Miniaturansichten","b":"b","Add files to the upload queue and click the start button.":"F\u00fcgen Sie Dateien zum Hochladen hinzu und Klicken Sie den Startbutton.","Drag files here.":"Dateien hierhin ziehen.","Start Upload":"Hochladen beginnen","Uploaded %d\/%d files":"%d\/%d Dateien hochgeladen","File extension error.":"Dateierweiterung-Fehler","File size error.":"Dateigr\u00f6\u00dfe-Fehler","Init error.":"Initialisierungsfehler","HTTP Error.":"HTTP-Fehler.","%d files queued":"%d Dateien in der Warteschlange","Please wait while your files are being uploaded.":"Dateien werden hochgeladen. Bitte warten.","Upload element accepts only %d file(s) at a time. Extra files were stripped.":"Das Upload-Element erlaubt nur %d Datei(en) gleichzeitig. Weitere Dateien wurden entfernt.","File count error.":"Fehler in der Dateianzahl.","Add Files":"Dateien hinzuf\u00fcgen","Insert this token into your form":"Dieses Token in Ihr Formular einf\u00fcgen","First click a text field to insert your tokens into.":"Klicken Sie zun\u00e4chst auf ein Textfeld, um Ihr Token einzuf\u00fcgen.","No revision":"Keine Revision"}},"pluralFormula":{"1":0,"default":1}};;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

window.Drupal = {
  behaviors: {},
  locale: {}
};

(function (Drupal, drupalSettings, drupalTranslations, console, Proxy, Reflect) {
  Drupal.throwError = function (error) {
    setTimeout(function () {
      throw error;
    }, 0);
  };

  Drupal.attachBehaviors = function (context, settings) {
    context = context || document;
    settings = settings || drupalSettings;
    var behaviors = Drupal.behaviors;
    Object.keys(behaviors || {}).forEach(function (i) {
      if (typeof behaviors[i].attach === 'function') {
        try {
          behaviors[i].attach(context, settings);
        } catch (e) {
          Drupal.throwError(e);
        }
      }
    });
  };

  Drupal.detachBehaviors = function (context, settings, trigger) {
    context = context || document;
    settings = settings || drupalSettings;
    trigger = trigger || 'unload';
    var behaviors = Drupal.behaviors;
    Object.keys(behaviors || {}).forEach(function (i) {
      if (typeof behaviors[i].detach === 'function') {
        try {
          behaviors[i].detach(context, settings, trigger);
        } catch (e) {
          Drupal.throwError(e);
        }
      }
    });
  };

  Drupal.checkPlain = function (str) {
    str = str.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    return str;
  };

  Drupal.formatString = function (str, args) {
    var processedArgs = {};
    Object.keys(args || {}).forEach(function (key) {
      switch (key.charAt(0)) {
        case '@':
          processedArgs[key] = Drupal.checkPlain(args[key]);
          break;

        case '!':
          processedArgs[key] = args[key];
          break;

        default:
          processedArgs[key] = Drupal.theme('placeholder', args[key]);
          break;
      }
    });
    return Drupal.stringReplace(str, processedArgs, null);
  };

  Drupal.stringReplace = function (str, args, keys) {
    if (str.length === 0) {
      return str;
    }

    if (!Array.isArray(keys)) {
      keys = Object.keys(args || {});
      keys.sort(function (a, b) {
        return a.length - b.length;
      });
    }

    if (keys.length === 0) {
      return str;
    }

    var key = keys.pop();
    var fragments = str.split(key);

    if (keys.length) {
      for (var i = 0; i < fragments.length; i++) {
        fragments[i] = Drupal.stringReplace(fragments[i], args, keys.slice(0));
      }
    }

    return fragments.join(args[key]);
  };

  Drupal.t = function (str, args, options) {
    options = options || {};
    options.context = options.context || '';

    if (typeof drupalTranslations !== 'undefined' && drupalTranslations.strings && drupalTranslations.strings[options.context] && drupalTranslations.strings[options.context][str]) {
      str = drupalTranslations.strings[options.context][str];
    }

    if (args) {
      str = Drupal.formatString(str, args);
    }

    return str;
  };

  Drupal.url = function (path) {
    return drupalSettings.path.baseUrl + drupalSettings.path.pathPrefix + path;
  };

  Drupal.url.toAbsolute = function (url) {
    var urlParsingNode = document.createElement('a');

    try {
      url = decodeURIComponent(url);
    } catch (e) {}

    urlParsingNode.setAttribute('href', url);
    return urlParsingNode.cloneNode(false).href;
  };

  Drupal.url.isLocal = function (url) {
    var absoluteUrl = Drupal.url.toAbsolute(url);
    var protocol = window.location.protocol;

    if (protocol === 'http:' && absoluteUrl.indexOf('https:') === 0) {
      protocol = 'https:';
    }

    var baseUrl = "".concat(protocol, "//").concat(window.location.host).concat(drupalSettings.path.baseUrl.slice(0, -1));

    try {
      absoluteUrl = decodeURIComponent(absoluteUrl);
    } catch (e) {}

    try {
      baseUrl = decodeURIComponent(baseUrl);
    } catch (e) {}

    return absoluteUrl === baseUrl || absoluteUrl.indexOf("".concat(baseUrl, "/")) === 0;
  };

  Drupal.formatPlural = function (count, singular, plural, args, options) {
    args = args || {};
    args['@count'] = count;
    var pluralDelimiter = drupalSettings.pluralDelimiter;
    var translations = Drupal.t(singular + pluralDelimiter + plural, args, options).split(pluralDelimiter);
    var index = 0;

    if (typeof drupalTranslations !== 'undefined' && drupalTranslations.pluralFormula) {
      index = count in drupalTranslations.pluralFormula ? drupalTranslations.pluralFormula[count] : drupalTranslations.pluralFormula.default;
    } else if (args['@count'] !== 1) {
      index = 1;
    }

    return translations[index];
  };

  Drupal.encodePath = function (item) {
    return window.encodeURIComponent(item).replace(/%2F/g, '/');
  };

  Drupal.deprecationError = function (_ref) {
    var message = _ref.message;

    if (drupalSettings.suppressDeprecationErrors === false && typeof console !== 'undefined' && console.warn) {
      console.warn("[Deprecation] ".concat(message));
    }
  };

  Drupal.deprecatedProperty = function (_ref2) {
    var target = _ref2.target,
        deprecatedProperty = _ref2.deprecatedProperty,
        message = _ref2.message;

    if (!Proxy || !Reflect) {
      return target;
    }

    return new Proxy(target, {
      get: function get(target, key) {
        if (key === deprecatedProperty) {
          Drupal.deprecationError({
            message: message
          });
        }

        for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          rest[_key - 2] = arguments[_key];
        }

        return Reflect.get.apply(Reflect, [target, key].concat(rest));
      }
    });
  };

  Drupal.theme = function (func) {
    if (func in Drupal.theme) {
      var _Drupal$theme;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return (_Drupal$theme = Drupal.theme)[func].apply(_Drupal$theme, args);
    }
  };

  Drupal.theme.placeholder = function (str) {
    return "<em class=\"placeholder\">".concat(Drupal.checkPlain(str), "</em>");
  };
})(Drupal, window.drupalSettings, window.drupalTranslations, window.console, window.Proxy, window.Reflect);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

if (window.jQuery) {
  jQuery.noConflict();
}

document.documentElement.className += ' js';

(function (Drupal, drupalSettings) {
  var domReady = function domReady(callback) {
    var listener = function listener() {
      callback();
      document.removeEventListener('DOMContentLoaded', listener);
    };

    if (document.readyState !== 'loading') {
      setTimeout(callback, 0);
    } else {
      document.addEventListener('DOMContentLoaded', listener);
    }
  };

  domReady(function () {
    Drupal.attachBehaviors(document, drupalSettings);
  });
})(Drupal, window.drupalSettings);;
/*! picturefill - v3.0.2 - 2016-02-12
 * https://scottjehl.github.io/picturefill/
 * Copyright (c) 2016 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT
 */
!function(a){var b=navigator.userAgent;a.HTMLPictureElement&&/ecko/.test(b)&&b.match(/rv\:(\d+)/)&&RegExp.$1<45&&addEventListener("resize",function(){var b,c=document.createElement("source"),d=function(a){var b,d,e=a.parentNode;"PICTURE"===e.nodeName.toUpperCase()?(b=c.cloneNode(),e.insertBefore(b,e.firstElementChild),setTimeout(function(){e.removeChild(b)})):(!a._pfLastSize||a.offsetWidth>a._pfLastSize)&&(a._pfLastSize=a.offsetWidth,d=a.sizes,a.sizes+=",100vw",setTimeout(function(){a.sizes=d}))},e=function(){var a,b=document.querySelectorAll("picture > img, img[srcset][sizes]");for(a=0;a<b.length;a++)d(b[a])},f=function(){clearTimeout(b),b=setTimeout(e,99)},g=a.matchMedia&&matchMedia("(orientation: landscape)"),h=function(){f(),g&&g.addListener&&g.addListener(f)};return c.srcset="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",/^[c|i]|d$/.test(document.readyState||"")?h():document.addEventListener("DOMContentLoaded",h),f}())}(window),function(a,b,c){"use strict";function d(a){return" "===a||"	"===a||"\n"===a||"\f"===a||"\r"===a}function e(b,c){var d=new a.Image;return d.onerror=function(){A[b]=!1,ba()},d.onload=function(){A[b]=1===d.width,ba()},d.src=c,"pending"}function f(){M=!1,P=a.devicePixelRatio,N={},O={},s.DPR=P||1,Q.width=Math.max(a.innerWidth||0,z.clientWidth),Q.height=Math.max(a.innerHeight||0,z.clientHeight),Q.vw=Q.width/100,Q.vh=Q.height/100,r=[Q.height,Q.width,P].join("-"),Q.em=s.getEmValue(),Q.rem=Q.em}function g(a,b,c,d){var e,f,g,h;return"saveData"===B.algorithm?a>2.7?h=c+1:(f=b-c,e=Math.pow(a-.6,1.5),g=f*e,d&&(g+=.1*e),h=a+g):h=c>1?Math.sqrt(a*b):a,h>c}function h(a){var b,c=s.getSet(a),d=!1;"pending"!==c&&(d=r,c&&(b=s.setRes(c),s.applySetCandidate(b,a))),a[s.ns].evaled=d}function i(a,b){return a.res-b.res}function j(a,b,c){var d;return!c&&b&&(c=a[s.ns].sets,c=c&&c[c.length-1]),d=k(b,c),d&&(b=s.makeUrl(b),a[s.ns].curSrc=b,a[s.ns].curCan=d,d.res||aa(d,d.set.sizes)),d}function k(a,b){var c,d,e;if(a&&b)for(e=s.parseSet(b),a=s.makeUrl(a),c=0;c<e.length;c++)if(a===s.makeUrl(e[c].url)){d=e[c];break}return d}function l(a,b){var c,d,e,f,g=a.getElementsByTagName("source");for(c=0,d=g.length;d>c;c++)e=g[c],e[s.ns]=!0,f=e.getAttribute("srcset"),f&&b.push({srcset:f,media:e.getAttribute("media"),type:e.getAttribute("type"),sizes:e.getAttribute("sizes")})}function m(a,b){function c(b){var c,d=b.exec(a.substring(m));return d?(c=d[0],m+=c.length,c):void 0}function e(){var a,c,d,e,f,i,j,k,l,m=!1,o={};for(e=0;e<h.length;e++)f=h[e],i=f[f.length-1],j=f.substring(0,f.length-1),k=parseInt(j,10),l=parseFloat(j),X.test(j)&&"w"===i?((a||c)&&(m=!0),0===k?m=!0:a=k):Y.test(j)&&"x"===i?((a||c||d)&&(m=!0),0>l?m=!0:c=l):X.test(j)&&"h"===i?((d||c)&&(m=!0),0===k?m=!0:d=k):m=!0;m||(o.url=g,a&&(o.w=a),c&&(o.d=c),d&&(o.h=d),d||c||a||(o.d=1),1===o.d&&(b.has1x=!0),o.set=b,n.push(o))}function f(){for(c(T),i="",j="in descriptor";;){if(k=a.charAt(m),"in descriptor"===j)if(d(k))i&&(h.push(i),i="",j="after descriptor");else{if(","===k)return m+=1,i&&h.push(i),void e();if("("===k)i+=k,j="in parens";else{if(""===k)return i&&h.push(i),void e();i+=k}}else if("in parens"===j)if(")"===k)i+=k,j="in descriptor";else{if(""===k)return h.push(i),void e();i+=k}else if("after descriptor"===j)if(d(k));else{if(""===k)return void e();j="in descriptor",m-=1}m+=1}}for(var g,h,i,j,k,l=a.length,m=0,n=[];;){if(c(U),m>=l)return n;g=c(V),h=[],","===g.slice(-1)?(g=g.replace(W,""),e()):f()}}function n(a){function b(a){function b(){f&&(g.push(f),f="")}function c(){g[0]&&(h.push(g),g=[])}for(var e,f="",g=[],h=[],i=0,j=0,k=!1;;){if(e=a.charAt(j),""===e)return b(),c(),h;if(k){if("*"===e&&"/"===a[j+1]){k=!1,j+=2,b();continue}j+=1}else{if(d(e)){if(a.charAt(j-1)&&d(a.charAt(j-1))||!f){j+=1;continue}if(0===i){b(),j+=1;continue}e=" "}else if("("===e)i+=1;else if(")"===e)i-=1;else{if(","===e){b(),c(),j+=1;continue}if("/"===e&&"*"===a.charAt(j+1)){k=!0,j+=2;continue}}f+=e,j+=1}}}function c(a){return k.test(a)&&parseFloat(a)>=0?!0:l.test(a)?!0:"0"===a||"-0"===a||"+0"===a?!0:!1}var e,f,g,h,i,j,k=/^(?:[+-]?[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i,l=/^calc\((?:[0-9a-z \.\+\-\*\/\(\)]+)\)$/i;for(f=b(a),g=f.length,e=0;g>e;e++)if(h=f[e],i=h[h.length-1],c(i)){if(j=i,h.pop(),0===h.length)return j;if(h=h.join(" "),s.matchesMedia(h))return j}return"100vw"}b.createElement("picture");var o,p,q,r,s={},t=!1,u=function(){},v=b.createElement("img"),w=v.getAttribute,x=v.setAttribute,y=v.removeAttribute,z=b.documentElement,A={},B={algorithm:""},C="data-pfsrc",D=C+"set",E=navigator.userAgent,F=/rident/.test(E)||/ecko/.test(E)&&E.match(/rv\:(\d+)/)&&RegExp.$1>35,G="currentSrc",H=/\s+\+?\d+(e\d+)?w/,I=/(\([^)]+\))?\s*(.+)/,J=a.picturefillCFG,K="position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)",L="font-size:100%!important;",M=!0,N={},O={},P=a.devicePixelRatio,Q={px:1,"in":96},R=b.createElement("a"),S=!1,T=/^[ \t\n\r\u000c]+/,U=/^[, \t\n\r\u000c]+/,V=/^[^ \t\n\r\u000c]+/,W=/[,]+$/,X=/^\d+$/,Y=/^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,Z=function(a,b,c,d){a.addEventListener?a.addEventListener(b,c,d||!1):a.attachEvent&&a.attachEvent("on"+b,c)},$=function(a){var b={};return function(c){return c in b||(b[c]=a(c)),b[c]}},_=function(){var a=/^([\d\.]+)(em|vw|px)$/,b=function(){for(var a=arguments,b=0,c=a[0];++b in a;)c=c.replace(a[b],a[++b]);return c},c=$(function(a){return"return "+b((a||"").toLowerCase(),/\band\b/g,"&&",/,/g,"||",/min-([a-z-\s]+):/g,"e.$1>=",/max-([a-z-\s]+):/g,"e.$1<=",/calc([^)]+)/g,"($1)",/(\d+[\.]*[\d]*)([a-z]+)/g,"($1 * e.$2)",/^(?!(e.[a-z]|[0-9\.&=|><\+\-\*\(\)\/])).*/gi,"")+";"});return function(b,d){var e;if(!(b in N))if(N[b]=!1,d&&(e=b.match(a)))N[b]=e[1]*Q[e[2]];else try{N[b]=new Function("e",c(b))(Q)}catch(f){}return N[b]}}(),aa=function(a,b){return a.w?(a.cWidth=s.calcListLength(b||"100vw"),a.res=a.w/a.cWidth):a.res=a.d,a},ba=function(a){if(t){var c,d,e,f=a||{};if(f.elements&&1===f.elements.nodeType&&("IMG"===f.elements.nodeName.toUpperCase()?f.elements=[f.elements]:(f.context=f.elements,f.elements=null)),c=f.elements||s.qsa(f.context||b,f.reevaluate||f.reselect?s.sel:s.selShort),e=c.length){for(s.setupRun(f),S=!0,d=0;e>d;d++)s.fillImg(c[d],f);s.teardownRun(f)}}};o=a.console&&console.warn?function(a){console.warn(a)}:u,G in v||(G="src"),A["image/jpeg"]=!0,A["image/gif"]=!0,A["image/png"]=!0,A["image/svg+xml"]=b.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1"),s.ns=("pf"+(new Date).getTime()).substr(0,9),s.supSrcset="srcset"in v,s.supSizes="sizes"in v,s.supPicture=!!a.HTMLPictureElement,s.supSrcset&&s.supPicture&&!s.supSizes&&!function(a){v.srcset="data:,a",a.src="data:,a",s.supSrcset=v.complete===a.complete,s.supPicture=s.supSrcset&&s.supPicture}(b.createElement("img")),s.supSrcset&&!s.supSizes?!function(){var a="data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw==",c="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",d=b.createElement("img"),e=function(){var a=d.width;2===a&&(s.supSizes=!0),q=s.supSrcset&&!s.supSizes,t=!0,setTimeout(ba)};d.onload=e,d.onerror=e,d.setAttribute("sizes","9px"),d.srcset=c+" 1w,"+a+" 9w",d.src=c}():t=!0,s.selShort="picture>img,img[srcset]",s.sel=s.selShort,s.cfg=B,s.DPR=P||1,s.u=Q,s.types=A,s.setSize=u,s.makeUrl=$(function(a){return R.href=a,R.href}),s.qsa=function(a,b){return"querySelector"in a?a.querySelectorAll(b):[]},s.matchesMedia=function(){return a.matchMedia&&(matchMedia("(min-width: 0.1em)")||{}).matches?s.matchesMedia=function(a){return!a||matchMedia(a).matches}:s.matchesMedia=s.mMQ,s.matchesMedia.apply(this,arguments)},s.mMQ=function(a){return a?_(a):!0},s.calcLength=function(a){var b=_(a,!0)||!1;return 0>b&&(b=!1),b},s.supportsType=function(a){return a?A[a]:!0},s.parseSize=$(function(a){var b=(a||"").match(I);return{media:b&&b[1],length:b&&b[2]}}),s.parseSet=function(a){return a.cands||(a.cands=m(a.srcset,a)),a.cands},s.getEmValue=function(){var a;if(!p&&(a=b.body)){var c=b.createElement("div"),d=z.style.cssText,e=a.style.cssText;c.style.cssText=K,z.style.cssText=L,a.style.cssText=L,a.appendChild(c),p=c.offsetWidth,a.removeChild(c),p=parseFloat(p,10),z.style.cssText=d,a.style.cssText=e}return p||16},s.calcListLength=function(a){if(!(a in O)||B.uT){var b=s.calcLength(n(a));O[a]=b?b:Q.width}return O[a]},s.setRes=function(a){var b;if(a){b=s.parseSet(a);for(var c=0,d=b.length;d>c;c++)aa(b[c],a.sizes)}return b},s.setRes.res=aa,s.applySetCandidate=function(a,b){if(a.length){var c,d,e,f,h,k,l,m,n,o=b[s.ns],p=s.DPR;if(k=o.curSrc||b[G],l=o.curCan||j(b,k,a[0].set),l&&l.set===a[0].set&&(n=F&&!b.complete&&l.res-.1>p,n||(l.cached=!0,l.res>=p&&(h=l))),!h)for(a.sort(i),f=a.length,h=a[f-1],d=0;f>d;d++)if(c=a[d],c.res>=p){e=d-1,h=a[e]&&(n||k!==s.makeUrl(c.url))&&g(a[e].res,c.res,p,a[e].cached)?a[e]:c;break}h&&(m=s.makeUrl(h.url),o.curSrc=m,o.curCan=h,m!==k&&s.setSrc(b,h),s.setSize(b))}},s.setSrc=function(a,b){var c;a.src=b.url,"image/svg+xml"===b.set.type&&(c=a.style.width,a.style.width=a.offsetWidth+1+"px",a.offsetWidth+1&&(a.style.width=c))},s.getSet=function(a){var b,c,d,e=!1,f=a[s.ns].sets;for(b=0;b<f.length&&!e;b++)if(c=f[b],c.srcset&&s.matchesMedia(c.media)&&(d=s.supportsType(c.type))){"pending"===d&&(c=d),e=c;break}return e},s.parseSets=function(a,b,d){var e,f,g,h,i=b&&"PICTURE"===b.nodeName.toUpperCase(),j=a[s.ns];(j.src===c||d.src)&&(j.src=w.call(a,"src"),j.src?x.call(a,C,j.src):y.call(a,C)),(j.srcset===c||d.srcset||!s.supSrcset||a.srcset)&&(e=w.call(a,"srcset"),j.srcset=e,h=!0),j.sets=[],i&&(j.pic=!0,l(b,j.sets)),j.srcset?(f={srcset:j.srcset,sizes:w.call(a,"sizes")},j.sets.push(f),g=(q||j.src)&&H.test(j.srcset||""),g||!j.src||k(j.src,f)||f.has1x||(f.srcset+=", "+j.src,f.cands.push({url:j.src,d:1,set:f}))):j.src&&j.sets.push({srcset:j.src,sizes:null}),j.curCan=null,j.curSrc=c,j.supported=!(i||f&&!s.supSrcset||g&&!s.supSizes),h&&s.supSrcset&&!j.supported&&(e?(x.call(a,D,e),a.srcset=""):y.call(a,D)),j.supported&&!j.srcset&&(!j.src&&a.src||a.src!==s.makeUrl(j.src))&&(null===j.src?a.removeAttribute("src"):a.src=j.src),j.parsed=!0},s.fillImg=function(a,b){var c,d=b.reselect||b.reevaluate;a[s.ns]||(a[s.ns]={}),c=a[s.ns],(d||c.evaled!==r)&&((!c.parsed||b.reevaluate)&&s.parseSets(a,a.parentNode,b),c.supported?c.evaled=r:h(a))},s.setupRun=function(){(!S||M||P!==a.devicePixelRatio)&&f()},s.supPicture?(ba=u,s.fillImg=u):!function(){var c,d=a.attachEvent?/d$|^c/:/d$|^c|^i/,e=function(){var a=b.readyState||"";f=setTimeout(e,"loading"===a?200:999),b.body&&(s.fillImgs(),c=c||d.test(a),c&&clearTimeout(f))},f=setTimeout(e,b.body?9:99),g=function(a,b){var c,d,e=function(){var f=new Date-d;b>f?c=setTimeout(e,b-f):(c=null,a())};return function(){d=new Date,c||(c=setTimeout(e,b))}},h=z.clientHeight,i=function(){M=Math.max(a.innerWidth||0,z.clientWidth)!==Q.width||z.clientHeight!==h,h=z.clientHeight,M&&s.fillImgs()};Z(a,"resize",g(i,99)),Z(b,"readystatechange",e)}(),s.picturefill=ba,s.fillImgs=ba,s.teardownRun=u,ba._=s,a.picturefillCFG={pf:s,push:function(a){var b=a.shift();"function"==typeof s[b]?s[b].apply(s,a):(B[b]=a[0],S&&s.fillImgs({reselect:!0}))}};for(;J&&J.length;)a.picturefillCFG.push(J.shift());a.picturefill=ba,"object"==typeof module&&"object"==typeof module.exports?module.exports=ba:"function"==typeof define&&define.amd&&define("picturefill",function(){return ba}),s.supPicture||(A["image/webp"]=e("image/webp","data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA=="))}(window,document);;
(function(drupalSettings, window) {
  var _paq = window._paq = window._paq || [];
  drupalSettings.analytics.options.forEach(e => {
    const a = Array.from(e);
    if(a[0] === 'setCustomUrl' && typeof URL === 'function') a[1] = (new URL(a[1], document.location)).toString();
    _paq.push(a);
  });
  var u=drupalSettings.analytics.url;
  _paq.push(['setTrackerUrl', u+'matomo.php']);
  var d=document, g=d.createElement('script'),
  s=d.getElementsByTagName('script')[0];
  g.async=true;
  g.src=u+'matomo.js';
  s.parentNode.insertBefore(g,s);
})(drupalSettings, window);
;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function (Drupal, drupalSettings) {
  Drupal.behaviors.activeLinks = {
    attach: function attach(context) {
      var path = drupalSettings.path;
      var queryString = JSON.stringify(path.currentQuery);
      var querySelector = path.currentQuery ? "[data-drupal-link-query='".concat(queryString, "']") : ':not([data-drupal-link-query])';
      var originalSelectors = ["[data-drupal-link-system-path=\"".concat(path.currentPath, "\"]")];
      var selectors;

      if (path.isFront) {
        originalSelectors.push('[data-drupal-link-system-path="<front>"]');
      }

      selectors = [].concat(originalSelectors.map(function (selector) {
        return "".concat(selector, ":not([hreflang])");
      }), originalSelectors.map(function (selector) {
        return "".concat(selector, "[hreflang=\"").concat(path.currentLanguage, "\"]");
      }));
      selectors = selectors.map(function (current) {
        return current + querySelector;
      });
      var activeLinks = context.querySelectorAll(selectors.join(','));
      var il = activeLinks.length;

      for (var i = 0; i < il; i++) {
        activeLinks[i].classList.add('is-active');
      }
    },
    detach: function detach(context, settings, trigger) {
      if (trigger === 'unload') {
        var activeLinks = context.querySelectorAll('[data-drupal-link-system-path].is-active');
        var il = activeLinks.length;

        for (var i = 0; i < il; i++) {
          activeLinks[i].classList.remove('is-active');
        }
      }
    }
  };
})(Drupal, drupalSettings);;
(function (Drupal, once) {
  'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var Drupal__default = /*#__PURE__*/_interopDefaultLegacy(Drupal);
  var once__default = /*#__PURE__*/_interopDefaultLegacy(once);

  const setupAriaCurrent = () => {
    // Adds aria-current=page attribute to each <a class="is-active"> inside
    // <nav>.
    //
    // Regrettably there is no sane way to customize link attributes for *active*
    // links in Drupal. This is because the `is-active` class is added from within
    // a response filter (see ActiveLinkResponseFilter.php) for anonymous users.
    // For authenticated users, the class is added using JavaScript.
    //
    // @see:
    // * core/lib/Drupal/Core/EventSubscriber/ActiveLinkResponseFilter.php
    // * core/misc/active-link.js
    // * https://www.drupal.org/project/aria_current
    const activeLinks = document.querySelectorAll('nav a.is-active');
    const il = activeLinks.length;
    for (let i = 0; i < il; i++) {
      activeLinks[i].setAttribute('aria-current', 'page');
    }
  };

  /**
   * Setup all toggle groups in the context.
   */
  function setupToggleButtonGroups(document, overlaySelector = '.modal-overlay') {
    // constants for attributes to avoid mispelling and abbreviate
    const aria = 'aria-expanded';
    const toggleGroupAttr = 'data-toggle-group';
    const toggleTargetAttr = 'data-toggle-visibility';

    const overlay = document.querySelector(overlaySelector);

    /**
     * @param {string} toggleGroup
     * @param {string?} activeTargetId
     */
    function setExpanded(toggleGroup, activeTargetId) {
      const groupSelector = `[${toggleGroupAttr}="${toggleGroup}"]`;
      const collapsedTargetIds = {};
      document.querySelectorAll(groupSelector).forEach(otherButton => {
        const buttonTargetId = otherButton.getAttribute(toggleTargetAttr);
        const buttonExpanded = activeTargetId && buttonTargetId == activeTargetId;
        otherButton.setAttribute(aria, buttonExpanded ? 'true' : 'false');
        if(!buttonExpanded) {
          collapsedTargetIds[buttonTargetId] = true;
        }
      });
      for (const collapsedTargetId in collapsedTargetIds) {
        const target = document.getElementById(collapsedTargetId);
        if(target && !target.hidden) {
          target.hidden = true;
        }
      }
      if(activeTargetId) {
        const target = document.getElementById(activeTargetId);
        if(target) {
          target.hidden = false;
        }
      }
    }

    /**
     * @this HTMLElement
     * @param {Event} event
     */
    function toggleButton(event) {
      // Prevent click from bubbling
      event.preventDefault();
      event.stopPropagation();
      // If false, set the target's's aria-expanded to `true`.
      const nextState = this.getAttribute(aria) === 'false';
      const targetId = this.getAttribute(toggleTargetAttr);
      const toggleGroup = this.getAttribute(toggleGroupAttr);
      setExpanded(toggleGroup, nextState ? targetId : null);

      // Toggle overlay if button has the overlay flag set.
      // Otherwise hide overlay
      if (overlay) {
        overlay.dataset.isActive = this.dataset.toggleOverlay === 'true' && nextState;
      }
    }

    // Setup buttons
    const toggleButtons = Array.from(document.querySelectorAll(`[${toggleGroupAttr}]`));
    toggleButtons.forEach(button => {
      if(!button.hasAttribute(aria)) {
        button.setAttribute(aria, 'false');
      }
      button.addEventListener('click', toggleButton);
    });

    // Setup overlay
    if (overlay) {
      overlay.addEventListener('click', () => {
        // Close all toggle grousp with the overlay flag and hide the overlay on click.
        overlay.dataset.isActive = false;
        const toggleGroupsWithModal = {};
        toggleButtons.forEach(button => {
          if(button.dataset.toggleOverlay === 'true') {
            toggleGroupsWithModal[button.dataset.toggleGroup] = true;
          }
        });
        for(const groupId in toggleGroupsWithModal) {
          setExpanded(groupId, null);
        }
      });
    }
  }

  /**
   * Constructs a select from all links found in the given element.
   *
   * @param {HTMLElement} control
   * @param {NodeList} links
   */
  const prepareMobilenavControl = (control, links) => {
    const document = control.ownerDocument;

    links.forEach((link) => {
      const option = document.createElement('option');
      option.innerText = link.innerText;
      option.value = link.href;
      control.appendChild(option);

      if (link.getAttribute('aria-current') == 'page') {
        control.value = link.href;
      }
    });
  };

  /**
   * Setup mobile navigation element.
   *
   * @param {HTMLElement} context
   * @param {Window} window
   */
  const setupMobilenav = (context, window) => {
    context.querySelectorAll('[data-mobilenav-control]').forEach((nav) => {
      const control = nav.querySelector(nav.dataset.mobilenavControl);
      const links = nav.querySelectorAll(nav.dataset.mobilenavLinks || "a");

      prepareMobilenavControl(control, links);

      control.addEventListener('change', (evt) => {
        window.location.assign(evt.target.value);
      });
    });
  };

  /**
   * Setup factbox toggle button.
   *
   * @param {Element} context
   */
  const setupFactboxToggle = (context) => {
    context.querySelectorAll('.content-fragment-factbox').forEach((factbox) => {
      const toggle = factbox.querySelector('button');
      if (toggle) {
        toggle.addEventListener('click', () => {
          const isExpanded = toggle.getAttribute('aria-expanded') === 'true';
          toggle.setAttribute('aria-expanded', isExpanded ? 'false' : 'true');
          factbox.dataset.expanded = isExpanded ? 'false' : 'true';
        });
      }
    });
  };

  /**
   * Setup list toggle button.
   *
   * @param {Element} context
   */
  const setupListToggle = (context) => {
    context.querySelectorAll(".content-fragment-list").forEach((list) => {
      const toggle = list.querySelector("button");
      if (toggle) {
        toggle.addEventListener("click", () => {
          const isExpanded = toggle.getAttribute("aria-expanded") === "true";
          toggle.setAttribute("aria-expanded", isExpanded ? "false" : "true");
          list.dataset.expanded = isExpanded ? "false" : "true";
        });
      }
    });
  };

  /**
   * Recompute img height and slide offsets.
   *
   * @param {Element} container
   */
  const slideshowRecompute = (container, window, reflow) => {
    const slidesContainer = container.querySelector('ul');

    const slides = slidesContainer.querySelectorAll('li');

    // Derive aspect ratio for this slideshow using the following method:
    // * Start with a minimum aspect ratio of 7:5 (0.71).
    // * For each slide compute the aspect ratio.
    // * Return the minimum.
    //
    // As a result, the aspect ratio is choosen to be the one of the widest image
    // in the slideshow.
    const aspectRatio = Array.from(slides).reduce((prev, slide) => {
      const img = slide.querySelector('img');
      const ratio = img ? (img.naturalHeight / img.naturalWidth) : prev;
      return Math.min(prev, ratio);
    }, 0.71);

    // Derive image height from container width. Include 0.2 margin (for following
    // image).
    const imgHeight = container.clientWidth * 0.8 * aspectRatio;

    // Size the slides container 20% wider than the sum of all images.
    let containerWidth = 0;
    slides.forEach((figure) => {
      const img = figure.querySelector('img');
      const ratio = img ? (img.naturalHeight / img.naturalWidth) : aspectRatio;
      const figureWidth = imgHeight / ratio;
      containerWidth = containerWidth + figureWidth;

      figure.style.width = `${figureWidth}px`;
    });

    slidesContainer.style.width = `${containerWidth * 1.2}px`;

    // Ensure all images have the same height.
    slides.forEach((figure) => {
      const img = figure.querySelector('img');
      if (img) {
        img.style.height = `${imgHeight}px`;
      }
    });

    // Sanitize activeSlide
    const numSlides = slides.length;
    if (!parseInt(container.dataset.activeSlide) || container.dataset.activeSlide < 0) {
      container.dataset.activeSlide = 0;
    }
    else if (container.dataset.activeSlide >= numSlides) {
      container.dataset.activeSlide = numSlides - 1;
    }

    if (reflow) {
      container.style.diplay = 'none';
      container.style.display = 'block';
    }

    // Push slides container to the correct position.
    const offset = slides[container.dataset.activeSlide].offsetLeft;
    const { marginLeft } = window.getComputedStyle(slidesContainer);
    const nextOffset = parseInt(marginLeft) - offset;
    slidesContainer.style.marginLeft = `${nextOffset}px`;

    // Fix button state.
    const prev = container.querySelector('.article-slideshow__controls__prev');
    if (prev) {
      prev.disabled = (container.dataset.activeSlide <= 0);
    }
    const next = container.querySelector('.article-slideshow__controls__next');
    if (next) {
      next.disabled = (container.dataset.activeSlide >= slides.length - 1);
    }

    // Fix active-slide state.
    slides.forEach((slide, index) => {
      slide.dataset.isActiveSlide = index == container.dataset.activeSlide;
    });
  };

  /**
   * Propagate resize event to all slideshows on page.
   */
  const slideshowsResizeAll = () => {
    document.querySelectorAll('.content-fragment-slideshow').forEach((slideshow) => {
      slideshowRecompute(slideshow, window);
    });
  };

  /**
   * Setup all slideshow inside context.
   *
   * @param {Element} context
   * @param {Window} window
   */
  const setupSlideshow = (context, window) => {
    context.querySelectorAll('.content-fragment-slideshow').forEach((slideshow) => {
      if (!slideshow.dataset.slideshowInitialized) {
        slideshowRecompute(slideshow, window);

        slideshow.querySelectorAll('img').forEach((img) => {
          img.addEventListener('load', () => {
            slideshowRecompute(slideshow, window);
          });
        });

        const prev = slideshow.querySelector('.article-slideshow__controls__prev');
        if (prev) {
          prev.addEventListener('click', () => {
            slideshow.dataset.activeSlide = parseInt(slideshow.dataset.activeSlide) - 1;
            slideshowRecompute(slideshow, window);
          });
        }

        const next = slideshow.querySelector('.article-slideshow__controls__next');
        if (next) {
          next.addEventListener('click', () => {
            slideshow.dataset.activeSlide = parseInt(slideshow.dataset.activeSlide) + 1;
            slideshowRecompute(slideshow, window);
          });
        }

        slideshow.dataset.slideshowInitialized = true;
      }
    });

    // In order to prevent repeated handler registration we do not use anonymous
    // functions here.
    window.addEventListener('resize', slideshowsResizeAll);
  };

  const blockTargetAttr = 'data-block-click-target';
  // Adapted from here https://inclusive-components.design/cards
  function onBlockLinkClicked(event) {
    const link = this.querySelector(this.getAttribute(blockTargetAttr));
    if(event.target.isSameNode(link)) {
      return;
    }
    var selectedText = "";
    // https://stackoverflow.com/questions/5379120/get-the-highlighted-selected-text
    // https://caniuse.com/?search=getSelection
    if (window.getSelection) {
      selectedText = window.getSelection().toString();
    }
    if (selectedText != "") {
      return
    }

    event.preventDefault();
    event.stopPropagation();
    link.click();
  }

  function setupBlockLinks() {
    // Keyboard events dont neeed to be handled because the link will do that for us.
    document.querySelectorAll('['+blockTargetAttr+']').forEach(block => {
      const link = block.querySelector(block.getAttribute(blockTargetAttr));
      if(link) {
        block.addEventListener('click', onBlockLinkClicked);
        block.className += " block-link";
      }
    });
  }

  /**
   * Setup parent expanded toggle button.
   *
   * @param {Element} context
   */
  const setupToggleParentExpanded = (context) => {
    context.querySelectorAll('[data-toggle-parent-expanded]').forEach((button) => {
      button.addEventListener('click', () => {
        const isExpanded = button.parentElement.getAttribute('aria-expanded') === 'true';
        button.parentElement.setAttribute('aria-expanded', isExpanded ? 'false' : 'true');
      });
    });
  };

  // Reference: http://www.html5rocks.com/en/tutorials/speed/animations/

  /**
   * Returns a function throttled to the browser paint cycle.
   *
   * @param {function} func
   * @returns {function} throttled function.
   */
  const throttled = (func) => {
    let reg = false;

    return (...args) => {
      if (!reg) {
        reg = true;
        window.requestAnimationFrame(() => {
          reg = false;
          func(...args);
        });
      }
    }
  };

  /**
   * Setup header minimization.
   *
   * @param {Document} document
   * @param {Window} window
   */
   const setupPageHeaderMinimization = (document, window) => {
    const header = document.querySelector('.page-header');

    if (header) {
      let lastPosition = 0;
      let lastDirection = 0;
      // let animating = [];

      // header.querySelectorAll('[data-transition-group="page-header"]').forEach((el) => {
      //   el.addEventListener('transitionrun', () => {
      //     animating = [...animating, el];
      //   });
      //   el.addEventListener('transitioncancel', () => {
      //     animating = animating.filter(item => item !== el);
      //   });
      //   el.addEventListener('transitionend', () => {
      //     animating = animating.filter(item => item !== el);
      //   });
      // });

      const trackScrolling = throttled(() => {
        // if (animating.length === 0) {
          const delta = window.scrollY - lastPosition;
          const direction = Math.sign(delta);
          if (direction > lastDirection && window.scrollY > 0) {
            header.classList.add('page-header--minimized');
          }
          if (direction < lastDirection || window.scrollY == 0) {
            header.classList.remove('page-header--minimized');
          }

          lastPosition = window.scrollY;
          lastDirection = direction;
        // }
      });

      document.addEventListener('scroll', trackScrolling);
    }
  };

  const selectorContainer = '[data-row-scroll-role="container"]';
  const selectorRow = '[data-row-scroll-role="scroll"]';
  const selectorNestedScrollStartTargets = '[data-row-scroll-role="target"]';
  const selectorFlatScrollStartTargets = ':scope > :not(hr)';


  /**
   *
   * @param {HTMLElement} row
   * @param {HTMLElement[]} scrollTargets
   * @returns {number[]}
   */
  function getScrollPositions(row, scrollTargets) {
    const positions = [];
    let lastPosition = -1;
    scrollTargets.forEach(element => {
      const leftOffset = element.offsetLeft;
      if(row.scrollWidth - leftOffset > row.offsetWidth) {
        if(lastPosition != leftOffset - row.offsetLeft) {
          positions.push(leftOffset - row.offsetLeft);
        }
        lastPosition = leftOffset - row.offsetLeft;
      }
    });
    // The following line would be the correct position, but we can also set it to a higher value
    // positions.push(row.scrollWidth - row.offsetWidth);
    // Somehow the correct value doesnt work in firefox so we use the scroll width :/
    positions.push(row.scrollWidth);
    return positions;
  }

  function getScrollTargets(row) {
    let targets = Array.from(row.querySelectorAll(selectorNestedScrollStartTargets));
    if(targets.length > 0) {
      return targets;
    } else {
      return Array.from(row.querySelectorAll(selectorFlatScrollStartTargets));
    }
  }

  /**
   * @param {HTMLElement} container 
   * @param {HTMLElement} row 
   */
  function initScrollableRow(container, row) {
    let lastScrollLeft = row.scrollLeft;
    let scrollTarget = 0;

    const img = document.createElement('img');
    img.src = "/themes/drei/assets/icons/chevron-right.svg";
    const leftButton = document.createElement("button");
    leftButton.appendChild(img);

    const rightButton = leftButton.cloneNode(true);
    rightButton.className = "scrollable-row--btn scrollable-row--btn--right";
    leftButton.className = "scrollable-row--btn scrollable-row--btn--left";
    container.appendChild(leftButton);
    container.appendChild(rightButton);
    const scrollTargets = getScrollTargets(row);

    /**
     * Evaluates the scroll direction and returns the next scroll target.
     */
    function getScrollTargetIndex() {
      const scrollLeft = row.scrollLeft;
      const direction = scrollLeft - lastScrollLeft;
      let toTheRight = null;
      let toTheLeft = 0;
      const positions = getScrollPositions(row, scrollTargets);
      positions.forEach((offsetLeft, index) => {
      // Array.from(row.children).filter(value => value.tagName == 'div').forEach(element => {
        if(offsetLeft >= scrollLeft && toTheRight == null) {
          toTheRight = index;
        }
        if(offsetLeft <= scrollLeft) {
          toTheLeft = index;
        }
      });
      lastScrollLeft = scrollLeft;
      if(direction >= 0) {
        if (toTheRight == null) {
          toTheRight = positions[positions.length - 1];
        }
        return {
          direction,
          targetIndex: toTheRight,
        };
      } else {
        return {
          direction,
          targetIndex: toTheLeft,
        };
      }
    }

    /**
     * @param {number} direction
     */
    function scrollRowScroll(direction) {
      scrollTarget = scrollTarget + direction;
      const positions = getScrollPositions(row, scrollTargets);
      scrollTarget = Math.min(Math.max(0, scrollTarget), positions.length - 1);
      const targetPosition = positions[scrollTarget];
      row.scrollTo({
        left: targetPosition, 
        top: 0,
        behavior: 'smooth',
      });
    }
    function updateScrollableRow() {
      const { direction, targetIndex } = getScrollTargetIndex();
      // Update stored scroll target if the user is scrolling in the opposite direction
      if ((scrollTarget === undefined) || (direction > 0 && targetIndex > scrollTarget) || (direction < 0 && targetIndex < scrollTarget)) {
        scrollTarget = targetIndex;
      }

      const currentScrollLeft = row.scrollLeft;
      const scrolledRight = (row.scrollWidth - row.offsetWidth - currentScrollLeft) < 10;
      const scrolledLeft = currentScrollLeft < 10;
      rightButton.disabled = scrolledRight;
      leftButton.disabled = scrolledLeft;
    }

    /**
     * @param {Event} event
     * @this HTMLElement The button
     */
    function onScrollableRowScrollLeft(event) {
      event.stopPropagation();
      scrollRowScroll(-1);
    }

    /**
     *
     * @param {Event} event
     * @this HTMLElement
     */
    function onScrollableRowScrollRight(event) {
      event.stopPropagation();
      scrollRowScroll(1);
    }

    let updateTimeout = null;
    row.addEventListener('scroll', function() {
      if(updateTimeout) {
        window.clearTimeout(updateTimeout);
      }
      updateTimeout = window.setTimeout(updateScrollableRow, 50);
    });

    leftButton.addEventListener('click', onScrollableRowScrollLeft);
    rightButton.addEventListener('click', onScrollableRowScrollRight);

    const resizeObserver = new ResizeObserver(function(entries) {
      // since we are observing only a single element, so we access the first element in entries array
      updateScrollableRow();
    });
    resizeObserver.observe(row);
  }

  /**
   *
   * @param {HTMLElement} context
   */
  function setupScrollableRow(context) {
    const mediaQuery = window.matchMedia("(pointer: coarse)");
    if(mediaQuery.matches) {
      return;
    }
    context.querySelectorAll(selectorContainer).forEach(container => {
      if(!container.dataset.scrollableRowSetup) {
        container.dataset.scrollableRowSetup = true;
        const row = container.querySelector(selectorRow);
        if(row) {
          initScrollableRow(container, row);
        }
      }
    });
  }

  /**
   * Setup market section menu toggles.
   *
   * @param {Element} context
   */
   const setupMarketSectionMenu = (context) => {
    context.querySelectorAll('.market-sections-menu').forEach((nav) => {
      const groups = nav.querySelectorAll('[aria-expanded]');

      groups.forEach((group) => {
        const link = group.querySelector('a');
        if(link) {
          link.addEventListener('click', (event) => {
            // Prevent click from bubbling
            event.preventDefault();
            event.stopPropagation();

            // Collapse other groups.
            groups.forEach(other => {
              if(!other.isSameNode(group)) {
                other.setAttribute('aria-expanded', 'false');
              }
            });

            // Toggle this group.
            const isExpanded = group.getAttribute('aria-expanded') === 'true';
            group.setAttribute('aria-expanded', isExpanded ? 'false' : 'true');
          });
        }    });
    });
  };

  /**
   * Setup factbox toggle button.
   *
   * @param {Element} context
   * @param {Window} window
   */
   const setupRaisenowWidget = (context, window) => {
    if (window.rnw) {
      window.rnw.tamaro.runWidget('.rnw-widget-container', {
        language: 'de',
        amounts: [
          {
            "if": "currency() == chf",
            "then": [25,50,75,100,200,500],
          }
        ],
        "showStoredCustomerDonationReceipt": false,
        }
      );
    }
  };

  /**
   * Setup checkout donation widget.
   *
   * @param {Element} context
   */
  const attachCheckoutDonationWidget = (context, settings, once) => {
    if (settings) {
      once('checkout-donation-widget', '[data-drei-checkout-donation]', context).forEach((fieldset) => {
        const document = fieldset.ownerDocument;
        const container = fieldset.querySelector('div');
        const numberField = container.querySelector('input');

        const numberSlider = document.createElement('input');
        numberSlider.type = 'range';
        numberSlider.min = parseInt(settings.slider.min);
        numberSlider.max = parseInt(settings.slider.max);
        numberSlider.step = parseInt(settings.slider.step);
        numberSlider.value = parseInt(settings.slider.value);

        const totalDisplay = document.createElement('span');
        totalDisplay.textContent = parseInt(settings.netAmount) + parseInt(settings.slider.value);

        numberSlider.addEventListener('change', () => {
          const donationValue = parseInt(numberSlider.value);
          numberField.value = donationValue;
          totalDisplay.innerText = parseInt(settings.netAmount) + donationValue;
        });

        numberField.addEventListener('change', () => {
          const donationValue = parseInt(numberField.value);
          numberSlider.value = donationValue;
          totalDisplay.innerText = parseInt(settings.netAmount) + donationValue;
        });

        const suggestions = document.createElement('ul');
        for (const suggestion of settings.suggestions) {
          const element = document.createElement('li');
          element.innerText = suggestion.label;
          element.addEventListener('click', () => {
            const donationValue = suggestion.value;
            numberSlider.value = donationValue;
            numberField.value = donationValue;
            totalDisplay.innerText = parseInt(settings.netAmount) + donationValue;
          });
          suggestions.appendChild(element);
        }

        const resetElement = document.createElement('li');
        resetElement.innerText = "x";
        resetElement.classList.add('checkout-donation__reset-link');
        resetElement.addEventListener('click', () => {
          const donationValue = 0;
          numberSlider.value = donationValue;
          numberField.value = donationValue;
          totalDisplay.innerText = parseInt(settings.netAmount) + donationValue;
        });
        suggestions.appendChild(resetElement);

        const widget = document.createElement('div');
        widget.classList.add('checkout-donation__widget');

        widget.appendChild(suggestions);
        widget.appendChild(numberSlider);
        widget.appendChild(totalDisplay);
        widget.appendChild(numberField);

        container.classList.add('checkout-donation');
        container.appendChild(widget);
      });
    }
  };

  function getOgValue(property) {
    const tag = document.querySelector(`meta[property="og:${property}"]`);
    if(tag) {
      return tag.getAttribute('content');
    }
  }

  function getShareData() {
    const title = getOgValue('title');
    const description = getOgValue('description');
    const url = getOgValue('url');
    if(!url || !title) return null;
    return {
      title,
      text: description,
      url,
    }
  }


  function trackSharing(type) {
    const _paq = window._paq || [];
    _paq.push(['trackEvent', 'share', type]);
  }

  /**
   *
   * @this HTMLElement
   * @param {Event} event
   */
  function onNativeShare() {
    const shareData = getShareData();
    trackSharing('native');
    try {
      navigator.share(shareData);
    } catch (e) {
    }
  }



  /**
   *
   * @this HTMLElement
   * @param {Event} event
   */
   function copyShortlinkToClipboard(event) {
    event.preventDefault();
    trackSharing('clipboard');
    const input = this.querySelector('input');
    input.focus();
    input.select();
    const result = document.execCommand('copy');
    if (result === 'unsuccessful') {
      console.error('Failed to copy text.');
    }
    this.classList.add('page-shortlink-copy--copied');
  }

  /**
   *
   * @this HTMLElement
   * @param {HTMLElement} menu
   */
  function setupShareLinks(menu, shareData) {
    // Don't use URL class, because spaces need to be encoded as %20 not +.

    menu.querySelectorAll('a[data-share-plattform]').forEach(link => {
      switch(link.getAttribute('data-share-plattform')) {
        case 'twitter':
          link.href ="https://twitter.com/intent/tweet?via=Wochenzeitung&url=" + encodeURIComponent(shareData.url) + "&text=" + encodeURIComponent(shareData.title);
          break;
        case 'facebook':
          link.href = 'https://www.facebook.com/sharer/sharer.php?u=' + encodeURIComponent(shareData.url);
          break;
        case 'mail': {
            let mailBody = shareData.url;
            if(shareData.text) {
              mailBody += '\n> ' + shareData.text + '\n';
            }
            link.href = 'mailto:?subject=' + encodeURIComponent(shareData.title) + '&body=' + encodeURIComponent(mailBody);
            link.addEventListener('click', function() {
              trackSharing('mail');
            });
          }
          break;
        case 'mastodon': {
          link.addEventListener('click', () => {
            const expaned = menu.getAttribute('data-share-menu-item-expanded') == "mastodon";
            if(expaned) {
              menu.removeAttribute('data-share-menu-item-expanded');
            } else {
              menu.setAttribute('data-share-menu-item-expanded', 'mastodon');
              const input = menu.querySelector('.sharing-widget-menu__mastodon-form form input[type="text"]');
              if(input) input.focus();
            }
          });
        }
        break;
      }
    });
    menu.querySelectorAll('input[data-share-plattform="clipboard"]').forEach(input => {
      input.value = shareData.url;
    });
    function submitMastodonForm(event) {
      event.preventDefault();
      const form = event.target;
      let instanceValue = form.instance.value;
      const re = /^(?:https?:\/\/)?([^/]+)/gi;
      const hostMatch = re.exec(instanceValue);
      if(hostMatch) {
        const url = 'https://' + hostMatch[0] + '/home?text=' + encodeURIComponent(shareData.title + '\n' + shareData.url + '\nvia @woz@troet.cafe');
        window.open(url);
      }
    }
    menu.querySelectorAll('.sharing-widget-menu__mastodon-form form').forEach(mastodonForm => {
      mastodonForm.addEventListener('submit', submitMastodonForm);
    });
    menu.querySelectorAll('.sharing-widget-menu__shortlink').forEach(element => {
      element.addEventListener('click', copyShortlinkToClipboard);
    });
  }

  /**
   *
   * @param {HTMLElement} context
   */
  function setupShareButton(context) {
    const shareData = getShareData();
    if(!shareData) {
      return;
    }
    let nativeShare = navigator.canShare && navigator.canShare(shareData);
    if(nativeShare) {
      context.querySelectorAll('.sharing-widget__share-button').forEach(button => {
        // Never toggle menu
        button.removeAttribute('data-toggle-visibility');
        button.removeAttribute('data-toggle-overlay');
        button.removeAttribute('data-toggle-group');
        button.removeAttribute('aria-expanded');
        // Call native sharing function
        button.addEventListener('click', onNativeShare);
        button.removeAttribute('hidden');
      });
    } else {
      const menu = document.getElementById('sharing-widget-menu');
      setupShareLinks(menu, shareData);
      // const dismiss = menu.querySelector('.sharing-widget-menu__dismiss-button');
      // dismiss.addEventListener('click', function(evt) {
      //   evt.preventDefault();
      //   button.click();
      // });
      context.querySelectorAll('.sharing-widget__share-button').forEach(button => {
        button.removeAttribute('hidden');
      });
    }
  }

  /**
   * Setup banner sets.
   *
   * @param {Element} context
   */
   const attachBannerSet = (context, once) => {
    once('banner-set', '[data-banner-set]', context).forEach((container) => {
      const now = new Date();
      const creatives = Array.from(container.querySelectorAll('[data-banner-role]'));
      const selection = creatives.filter((creative) => {
        if (creative.dataset.bannerNotBefore) {
          const notBefore = new Date(creative.dataset.bannerNotBefore);
          if (notBefore && notBefore.getTime() > now.getTime()) {
            return false;
          }
        }

        if (creative.dataset.bannerNotAfter) {
          const notAfter = new Date(creative.dataset.bannerNotAfter);
          if (notAfter && notAfter.getTime() < now.getTime()) {
            return false;
          }
        }

        return true;
      });

      const banners = selection.filter((creative) => creative.dataset.bannerRole == 'banner');
      const fillers = selection.filter((creative) => creative.dataset.bannerRole == 'filler');
      const candidates = banners.length > 0 ? banners : fillers;

      if (candidates.length) {
        const selection = Math.floor(Math.random() * candidates.length);
        candidates[selection].dataset.bannerCurrent="1";
      }
    });
  };

  /**
   * 
   * @param {Number} width 
   * @param {HTMLElement} video 
   */
  function enableSourceForWidth(width, video) {
      const sources = Array.from(video.querySelectorAll('source[data-video-width]'));
      if(sources.length) {
          const sourceMap = sources.map(source => [
              parseInt(source.dataset.videoWidth),
              source, 
          ]);
          sourceMap.sort((a, b) => a[0] - b[0]);
          let matchingSource = sourceMap.find(source => source[0] > width);
          if(matchingSource === undefined) {
              // No source is wider than screen
              matchingSource = sourceMap[sourceMap.length - 1];
          }        if(matchingSource[1].dataset.src !== undefined) {
              matchingSource[1].src = matchingSource[1].dataset.src;
              delete matchingSource[1].dataset.src;
              sources.forEach(s => {
                  if(!('src' in s.dataset) && !s.isSameNode(matchingSource[1])) {
                      // Deactivate source
                      s.dataset.src = s.src;
                      s.removeAttribute("src");
                  }
              });
          }
      }
  }


  /**
   * 
   * @param {HTMLElement} context 
   */
  function setupImageMovie(context) {
      const videos = context.querySelectorAll(".info-page-image-movie");
      const resizeObserver = new ResizeObserver((entries) => {
          for (let entry of entries) { 
              let width = 0;
              if(entry.contentBoxSize) {
                  if(entry.contentBoxSize[0]) {
                      width = entry.contentBoxSize[0].inlineSize;
                  } else {
                      width = entry.contentBoxSize.inlineSize;
                  }
              } else {
                  width = entry.contentRect.width;
              }
              enableSourceForWidth(width, entry.target);
          }
      });
      
      videos.forEach(video => {
          resizeObserver.observe(video);
          const clickEventListener = () => {
              video.load();
              video.play();
              video.parentElement.removeEventListener('click', clickEventListener);
          };
          video.parentElement.addEventListener('click', clickEventListener);
          video.addEventListener('play', () => {
              resizeObserver.unobserve(video);
              video.parentElement.dataset.videoPlaying = 'true';
              if(!video.classList.contains("info-page-image-movie--full-size")) {
                  video.classList.add('info-page-image-movie--expanding');
                  video.classList.add('info-page-image-movie--full-size');
              }
          });
          video.addEventListener('transitionend', function() {
              this.classList.remove('info-page-image-movie--expanding');
              this.controls = true;
          });
      });
  }

  /**
   * Simple algorithm which distributes m objects over a target array of length n
   * such that every object is spaced evenly relative to its predecessor and
   * successor and also from the start and end of the target array respectively.
   */
  class Pearlstring {

    /**
     * Constructs the placement algorithm.
     *
     * @param {Number} n Length of target array
     * @param {Number} m Number of objects to place
     */
    constructor(n, m) {
      this.step = (n + 1) / (m + 1);
    }

    /**
     * Given an object index, return an index into the target array.
     *
     * @param {Number} i Zero based index into the array of objects to place.
     * @returns Zero based index into the target array.
     */
    place(i) {
      return Math.floor(this.step * (i + 1)) - 1;
    }

  }

  /**
   * Return true if the given element starts with a text node.
   *
   * @param {Element} elem
   */
  const startsWithText = (elem) => {
    let result = false;

    for (const node of elem.childNodes) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        result = false;
        break;
      }
      if (node.nodeType === Node.TEXT_NODE && node.textContent.trim().length > 0) {
        result = true;
        break;
      }
    }

    return result;
  };

  /**
   * Check whether an insert is allowed after the given element.
   *
   * An insert is possible:
   * * After a <p>
   * * Only if the element has no additional class
   * * And only if there is text and no nested element at the start of the content.
   *
   * @param {Element} elem
   */
  const isValidPlacementAfter = (elem) => {
    const allowedTags = ['p'];
    return allowedTags.find((allowedTag) => allowedTag === elem.tagName.toLowerCase()) &&
      elem.classList.length === 0 &&
      startsWithText(elem);
  };

  /**
   * Check whether an insert is allowed before the given element.
   *
   * An insert is possible:
   * * Before a <p>, <h3> or <h4>
   * * Only if the element has no additional class
   * * And only if there is text and no nested element at the start of the content.
   *
   * @param {Element} elem
   */
  const isValidPlacementBefore = (elem) => {
    const allowedTags = ['p', 'h3', 'h4'];
    return allowedTags.find((allowedTag) => allowedTag === elem.tagName.toLowerCase()) &&
      elem.classList.length === 0 &&
      startsWithText(elem);
  };

  /**
   * Lift inserts (ads) into content according to the specified rules.
   *
   * @param {Element} context
   */
   const setupLiftSet = (context) => {
    const anchors = [];
    let textlen = 0;

    // Collect anchors, i.e., elements where an insert could follow.
    context.querySelectorAll('[data-lift-set-container]').forEach((container) => {
      anchors.push(...Array.from(container.children)
        .filter((child) => isValidPlacementAfter(child))
        .filter((child) => child.nextElementSibling && isValidPlacementBefore(child.nextElementSibling))
      );
      textlen += container.textContent.length;
    });

    // Collect insert candidates.
    const candidates = Array.from(context.querySelectorAll('[data-lift-set-placement]'));

    // Generate an ordered list of placement names. Each insert specifies the
    // desired placement name in its data-lift-set-placement attribute.
    // One placement for texts under 6000 chars, two for longer ones.
    const placementMax = textlen < 6000 ? 1 : 2;
    const placementNames = Array.from(
        new Set(candidates.map((elem) => elem.dataset.liftSetPlacement))
      )
      .filter((value) => value.trim())
      .sort()
      .slice(0, Math.min(placementMax, anchors.length));

    // Choose one insert for each placement name.
    const inserts = placementNames.map(
      (name) => candidates.find((elem) => elem.dataset.liftSetPlacement === name)
    );

    // Lift the selection of inserts into the anchors.
    const pearlstring = new Pearlstring(anchors.length, inserts.length);
    for (const [index, insert] of inserts.entries()) {
      anchors[pearlstring.place(index)].insertAdjacentElement('afterend', insert);
    }
  };

  const setup = (settings) => {
    setupAriaCurrent();
    // Share buttons must be set up before toggle buttons
    setupShareButton(document);
    setupToggleButtonGroups(document);
    setupBlockLinks();
    setupMobilenav(document, window);
    setupFactboxToggle(document);
    setupListToggle(document);
    setupSlideshow(document, window);
    setupToggleParentExpanded(document);
    setupPageHeaderMinimization(document, window);
    setupScrollableRow(document);
    setupMarketSectionMenu(document);
    setupRaisenowWidget(document, window);
    setupImageMovie(document);
    setupLiftSet(document);
  };

  const attach = (context, settings, once) => {
    attachCheckoutDonationWidget(context, settings?.drei?.checkoutDonation, once);
    attachBannerSet(context, once);
  };

  Drupal__default["default"].behaviors.themeDrei = {
    attach: function (context, settings) {
      once__default["default"]('theme-drei', 'html', context).forEach(() => {
        setup();
      });

      attach(context, settings, once__default["default"]);
    }
  };

})(Drupal, once);

;
